from flask import Flask, jsonify, request, send_file
from flask_cors import CORS
from celery import Celery
import os
import time
import uuid
import jwt
import asyncio
import threading
import logging
from datetime import datetime, timedelta
import logging # Ajouter l'import de logging ici
import httpx # Ajout de l'import httpx
import json # Ajout de l'import json pour la migration Vosk
 
# Configuration du logging pour le diagnostic
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("BACKEND_DIAGNOSTIC")

# Note: services LiveKit supprim√©s pour approche REST + Vosk pure

app = Flask(__name__)
CORS(app) # Active CORS pour toutes les routes

# Note: blueprint LiveKit supprim√© pour approche REST + Vosk

# Configuration Celery
app.config['CELERY_BROKER_URL'] = os.getenv('REDIS_URL', 'redis://redis:6379/0')
app.config['CELERY_RESULT_BACKEND'] = os.getenv('REDIS_URL', 'redis://redis:6379/0')

# Configuration LiveKit
LIVEKIT_URL_INTERNAL = os.getenv('LIVEKIT_URL', 'ws://livekit:7880')  # Pour Docker interne
LIVEKIT_URL_EXTERNAL = os.getenv('LIVEKIT_URL_EXTERNAL', 'ws://192.168.1.44:7880') # Rendre cette variable configurable

# Initialisation Celery
celery = Celery(
    app.import_name,
    broker=app.config['CELERY_BROKER_URL'],
    backend=app.config['CELERY_RESULT_BACKEND']
)
celery.conf.update(app.config)

# Configuration du logging pour le diagnostic
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger("BACKEND_DIAGNOSTIC")

# Registre des sessions actives pour √©viter les doublons
active_sessions = {}
session_lock = threading.Lock()

# T√¢ches Celery
@celery.task
def example_task(param):
    """T√¢che d'exemple pour tester Celery"""
    return f"T√¢che ex√©cut√©e avec le param√®tre: {param}"

@celery.task
def process_audio_task(audio_data):
    """T√¢che pour traiter l'audio"""
    # Logique de traitement audio ici
    return {"status": "processed", "data": audio_data}

@celery.task
def diagnostic_asr_task(audio_data):
    """DIAGNOSTIC: T√¢che Celery pour tester l'ASR"""
    logger.info(f"üîÑ DIAGNOSTIC: T√¢che ASR Celery ex√©cut√©e avec {len(audio_data) if audio_data else 0} bytes")
    try:
        # Simuler le traitement ASR
        import httpx
        import asyncio
        
        async def test_asr():
            async with httpx.AsyncClient() as client:
                response = await client.get("http://whisper-stt:8001/health", timeout=2.0)
                return response.status_code == 200
        
        # Ex√©cuter le test ASR
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        asr_available = loop.run_until_complete(test_asr())
        loop.close()
        
        if asr_available:
            logger.info("‚úÖ DIAGNOSTIC: Service ASR accessible depuis Celery")
            return {"status": "success", "asr_available": True}
        else:
            logger.warning("‚ö†Ô∏è DIAGNOSTIC: Service ASR non accessible depuis Celery")
            return {"status": "warning", "asr_available": False}
            
    except Exception as e:
        logger.error(f"‚ùå DIAGNOSTIC: Erreur t√¢che ASR Celery: {e}")
        return {"status": "error", "error": str(e)}

@celery.task
def diagnostic_tts_task(text):
    """DIAGNOSTIC: T√¢che Celery pour tester le TTS"""
    logger.info(f"üîÑ DIAGNOSTIC: T√¢che TTS Celery ex√©cut√©e avec texte: '{text[:50]}...'")
    try:
        # Simuler le traitement TTS
        import httpx
        import asyncio
        
        async def test_tts():
            async with httpx.AsyncClient() as client:
                response = await client.get("http://piper-tts:5002/health", timeout=2.0)
                return response.status_code == 200
        
        # Ex√©cuter le test TTS
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        tts_available = loop.run_until_complete(test_tts())
        loop.close()
        
        if tts_available:
            logger.info("‚úÖ DIAGNOSTIC: Service TTS accessible depuis Celery")
            return {"status": "success", "tts_available": True}
        else:
            logger.warning("‚ö†Ô∏è DIAGNOSTIC: Service TTS non accessible depuis Celery")
            return {"status": "warning", "tts_available": False}
            
    except Exception as e:
        logger.error(f"‚ùå DIAGNOSTIC: Erreur t√¢che TTS Celery: {e}")
        return {"status": "error", "error": str(e)}

@app.route('/')
def home():
    return "Bienvenue sur le backend Flask!"

@app.route('/health', methods=['GET'])
def health_check():
    return jsonify({"status": "healthy", "service": "eloquence-api"}), 200

@app.route('/api/data')
def get_data():
    data = {
        "message": "Donn√©es du backend Flask",
        "version": "1.0"
    }
    return jsonify(data)

@app.route('/api/test-celery')
def test_celery():
    """Endpoint pour tester Celery"""
    task = example_task.delay("test")
    return jsonify({"task_id": task.id, "status": "Task started"})

def generate_livekit_token(room_name: str, participant_identity: str) -> str:
    """G√©n√®re un token LiveKit pour un participant"""
    import time
    now_timestamp = int(time.time())
    exp_timestamp = now_timestamp + (24 * 3600)  # +24 heures
    
    # Log pour diagnostic
    logger.info(f"üîë G√âN√âRATION TOKEN: now={now_timestamp}, exp={exp_timestamp}")
    logger.info(f"üîë Date now: {datetime.fromtimestamp(now_timestamp)}")
    logger.info(f"üîë Date exp: {datetime.fromtimestamp(exp_timestamp)}")
    
    # CORRECTION: Format correct pour LiveKit
    payload = {
        'iss': os.getenv('LIVEKIT_API_KEY'),
        'sub': participant_identity,
        'iat': now_timestamp,
        'exp': exp_timestamp,
        'nbf': now_timestamp,
        'video': {
            'room': room_name,
            'roomJoin': True,
            'roomList': True,
            'roomRecord': False,
            'roomAdmin': False,
            'roomCreate': False,
            'canPublish': True,
            'canSubscribe': True,
            'canPublishData': True,
            'canUpdateOwnMetadata': True
        }
    }
    
    # CORRECTION CRITIQUE: Utiliser les bonnes cl√©s depuis les variables d'environnement
    api_key = os.getenv('LIVEKIT_API_KEY', 'devkey')
    api_secret = os.getenv('LIVEKIT_API_SECRET', 'secret')
    
    logger.info(f"üîë Utilisation cl√©s: API_KEY={api_key}, SECRET={'*' * len(api_secret)}")
    
    payload['iss'] = api_key
    
    return jwt.encode(payload, api_secret, algorithm='HS256')

@app.route('/api/scenarios', methods=['GET'])
def get_scenarios():
    """Retourne la liste des sc√©narios disponibles"""
    try:
        language = request.args.get('language', 'fr')
        
        # Sc√©narios de d√©monstration
        scenarios = [
            {
                "id": "demo-1",
                "title": "Entretien d'embauche" if language == 'fr' else "Job Interview",
                "description": "Pr√©parez-vous pour un entretien d'embauche avec un coach IA" if language == 'fr' else "Prepare for a job interview with an AI coach",
                "category": "professional",
                "difficulty": "intermediate",
                "duration_minutes": 15,
                "language": language,
                "tags": ["entretien", "professionnel", "coaching"] if language == 'fr' else ["interview", "professional", "coaching"],
                "created_at": "2025-06-17T00:00:00Z",
                "updated_at": "2025-06-17T00:00:00Z"
            },
            {
                "id": "demo-2",
                "title": "Pr√©sentation publique" if language == 'fr' else "Public Speaking",
                "description": "Am√©liorez vos comp√©tences de pr√©sentation en public" if language == 'fr' else "Improve your public speaking skills",
                "category": "communication",
                "difficulty": "advanced",
                "duration_minutes": 20,
                "language": language,
                "tags": ["pr√©sentation", "public", "communication"] if language == 'fr' else ["presentation", "public", "communication"],
                "created_at": "2025-06-17T00:00:00Z",
                "updated_at": "2025-06-17T00:00:00Z"
            },
            {
                "id": "demo-3",
                "title": "Conversation informelle" if language == 'fr' else "Casual Conversation",
                "description": "Pratiquez une conversation d√©tendue avec l'IA" if language == 'fr' else "Practice casual conversation with AI",
                "category": "social",
                "difficulty": "beginner",
                "duration_minutes": 10,
                "language": language,
                "tags": ["conversation", "social", "d√©butant"] if language == 'fr' else ["conversation", "social", "beginner"],
                "created_at": "2025-06-17T00:00:00Z",
                "updated_at": "2025-06-17T00:00:00Z"
            }
        ]
        
        logger.info(f"‚úÖ Sc√©narios r√©cup√©r√©s pour langue: {language}")
        return jsonify({
            "scenarios": scenarios,
            "total": len(scenarios),
            "language": language,
            "timestamp": datetime.utcnow().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"‚ùå Erreur r√©cup√©ration sc√©narios: {str(e)}")
        return jsonify({"error": f"Erreur lors de la r√©cup√©ration des sc√©narios: {str(e)}"}), 500

@app.route('/api/sessions', methods=['POST'])
def create_session():
    """Cr√©e une session LiveKit pour les tests"""
    try:
        data = request.get_json()
        
        # Validation des donn√©es requises
        if not data:
            return jsonify({"error": "Donn√©es JSON requises"}), 400
            
        user_id = data.get('user_id')
        scenario_id = data.get('scenario_id', 'default')
        language = data.get('language', 'fr')
        
        if not user_id:
            return jsonify({"error": "user_id requis"}), 400
        
        # Cl√© unique pour identifier la session
        session_key = f"{user_id}_{scenario_id}"
        
        with session_lock:
            # V√©rifier si une session active existe d√©j√†
            if session_key in active_sessions:
                existing_session = active_sessions[session_key]
                # V√©rifier si la session est encore valide (moins de 30 minutes)
                session_age = time.time() - existing_session.get('created_timestamp', 0)
                if session_age < 1800:  # 30 minutes
                    logger.info(f"üîÑ R√©utilisation session existante: {existing_session['room_name']}")
                    # R√©g√©n√©rer le token pour le client
                    new_token = generate_livekit_token(existing_session['room_name'], f"user_{user_id}")
                    existing_session['livekit_token'] = new_token
                    return jsonify(existing_session), 200
                else:
                    # Session expir√©e, la supprimer
                    logger.info(f"üóëÔ∏è Session expir√©e supprim√©e: {existing_session['room_name']}")
                    del active_sessions[session_key]
        
        # Cr√©er une nouvelle session
        room_name = f"session_{scenario_id}_{int(time.time())}"
        
        # G√©n√©rer le token LiveKit
        participant_identity = f"user_{user_id}"
        livekit_token = generate_livekit_token(room_name, participant_identity)
        
        # Message initial selon le sc√©nario
        initial_messages = {
            'debat_politique': "Bienvenue dans ce d√©bat politique. Je suis votre interlocuteur IA. Quel sujet souhaitez-vous aborder ?",
            'coaching_vocal': "Bonjour ! Je suis votre coach vocal IA. Commen√ßons par quelques exercices de diction.",
            'default': "Bonjour ! Je suis votre assistant IA. Comment puis-je vous aider aujourd'hui ?"
        }
        
        initial_message = initial_messages.get(scenario_id, initial_messages['default'])
        
        # R√©ponse avec les informations de session
        session_data = {
            "session_id": str(uuid.uuid4()),
            "user_id": user_id,
            "scenario_id": scenario_id,
            "language": language,
            "room_name": room_name,
            "livekit_url": LIVEKIT_URL_EXTERNAL,  # Utiliser l'URL externe pour les clients
            "livekit_token": livekit_token,
            "participant_identity": participant_identity,
            "initial_message": {
                "text": initial_message,
                "timestamp": int(time.time())
            },
            "created_at": datetime.utcnow().isoformat(),
            "created_timestamp": time.time(),  # Pour v√©rifier l'expiration
            "status": "active"
        }
        
        # CORRECTION CRITIQUE: Connecter l'agent AUTOMATIQUEMENT avec identit√© unique
        unique_suffix = f"{int(time.time())}_{str(uuid.uuid4())[:8]}"
        agent_identity = f"ai_agent_{unique_suffix}"
        
        logger.info(f"ü§ñ LANCEMENT AGENT AUTOMATIQUE pour room: {room_name} avec identit√©: {agent_identity}")
        
        # Ajouter l'identit√© unique aux donn√©es de session avant de d√©marrer l'agent
        session_data['agent_identity'] = agent_identity
        
        # Note: Connexion agent d√©sactiv√©e pour approche REST + Vosk
        logger.info(f"üîß Session REST + Vosk cr√©√©e sans agent LiveKit")
        session_data['agent_connected'] = False
        
        # Enregistrer la session dans le registre
        with session_lock:
            active_sessions[session_key] = session_data
            logger.info(f"üìù Session enregistr√©e: {room_name} (cl√©: {session_key})")
        
        # TEMPORAIRE: D√©sactiver Celery pour test agent
        logger.info("üîß DIAGNOSTIC: Tests Celery d√©sactiv√©s temporairement")
        
        return jsonify(session_data), 201
        
    except Exception as e:
        logger.error(f"‚ùå DIAGNOSTIC: Erreur cr√©ation session: {str(e)}")
        return jsonify({"error": f"Erreur lors de la cr√©ation de session: {str(e)}"}), 500

@app.route('/api/session/start', methods=['POST'])
def start_session():
    """Endpoint alternatif pour d√©marrer une session (compatibilit√©)"""
    try:
        data = request.get_json()
        
        # Validation des donn√©es requises
        if not data:
            return jsonify({"error": "Donn√©es JSON requises"}), 400
            
        user_id = data.get('user_id')
        scenario_id = data.get('scenario_id', 'default')
        language = data.get('language', 'fr')
        
        if not user_id:
            return jsonify({"error": "user_id requis"}), 400
        
        # G√©n√©rer un nom de room unique
        room_name = f"session_{scenario_id}_{int(time.time())}"
        
        # G√©n√©rer le token LiveKit
        participant_identity = f"user_{user_id}"
        livekit_token = generate_livekit_token(room_name, participant_identity)
        
        # R√©ponse simplifi√©e pour compatibilit√©
        session_data = {
            "session_id": str(uuid.uuid4()),
            "user_id": user_id,
            "scenario_id": scenario_id,
            "language": language,
            "room_name": room_name,
            "livekit_url": LIVEKIT_URL_EXTERNAL,
            "livekit_token": livekit_token,
            "participant_identity": participant_identity,
            "status": "active",
            "created_at": datetime.utcnow().isoformat()
        }
        
        logger.info(f"‚úÖ Session d√©marr√©e via endpoint alternatif: {session_data['session_id']}")
        return jsonify(session_data), 201
        
    except Exception as e:
        logger.error(f"‚ùå Erreur d√©marrage session: {str(e)}")
        return jsonify({"error": f"Erreur lors du d√©marrage de session: {str(e)}"}), 500

@app.route('/api/diagnostic', methods=['GET'])
def get_diagnostic_status():
    """
    DIAGNOSTIC: Endpoint pour v√©rifier l'√©tat des services
    """
    try:
        logger.info("üîß DIAGNOSTIC: V√©rification √©tat des services")
        
        diagnostic_data = {
            "timestamp": datetime.utcnow().isoformat(),
            "backend_status": "running",
            "services_status": {},
            "celery_status": "unknown"
        }
        
        # Tester la connectivit√© des services
        import httpx
        import asyncio
        
        async def test_services():
            services = {
                "asr": "http://whisper-stt:8001/health",
                "tts": "http://openai-tts:5002/health", # CHANG√â de piper-tts
                "redis": "redis://redis:6379"
            }
            
            results = {}
            
            # Test ASR
            try:
                async with httpx.AsyncClient() as client:
                    response = await client.get(services["asr"], timeout=2.0)
                    results["asr"] = {
                        "status": "ok" if response.status_code == 200 else "error",
                        "response_code": response.status_code
                    }
            except (httpx.RequestError, asyncio.TimeoutError) as e:
                results["asr"] = {"status": "error", "error": f"Connexion ASR √©chou√©e: {e}"}
            except Exception as e:
                results["asr"] = {"status": "error", "error": f"Erreur inattendue ASR: {e}"}
            
            # Test TTS
            try:
                async with httpx.AsyncClient() as client:
                    response = await client.get(services["tts"], timeout=2.0)
                    results["tts"] = {
                        "status": "ok" if response.status_code == 200 else "error",
                        "response_code": response.status_code
                    }
            except (httpx.RequestError, asyncio.TimeoutError) as e:
                results["tts"] = {"status": "error", "error": f"Connexion TTS √©chou√©e: {e}"}
            except Exception as e:
                results["tts"] = {"status": "error", "error": f"Erreur inattendue TTS: {e}"}
            
            # Test Redis (via Celery)
            try:
                test_task = example_task.delay("diagnostic_test")
                results["redis"] = {
                    "status": "ok",
                    "celery_task_id": test_task.id
                }
                diagnostic_data["celery_status"] = "ok"
            except Exception as e:
                results["redis"] = {"status": "error", "error": str(e)}
                diagnostic_data["celery_status"] = "error"
            
            return results
        
        # Ex√©cuter les tests de service
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        services_results = loop.run_until_complete(test_services())
        loop.close()
        
        diagnostic_data["services_status"] = services_results
        
        logger.info(f"‚úÖ DIAGNOSTIC: √âtat des services r√©cup√©r√©")
        return jsonify(diagnostic_data), 200
        
    except Exception as e:
        logger.error(f"‚ùå DIAGNOSTIC: Erreur r√©cup√©ration √©tat: {str(e)}")
        return jsonify({"error": f"Erreur diagnostic: {str(e)}"}), 500

@app.route('/api/diagnostic/logs', methods=['GET'])
def get_diagnostic_logs():
    """
    DIAGNOSTIC: Endpoint pour r√©cup√©rer les logs de diagnostic
    """
    try:
        # R√©cup√©rer les derniers logs (simulation)
        logs = []
        
        return jsonify({
            "logs": logs,
            "timestamp": datetime.utcnow().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"‚ùå DIAGNOSTIC: Erreur r√©cup√©ration logs: {str(e)}")
        return jsonify({"error": f"Erreur logs diagnostic: {str(e)}"}), 500

@app.route('/api/confidence-analysis', methods=['POST'])
async def analyze_confidence():
    """
    Analyse de confiance vocale avec VOSK + Mistral (corrig√©)
    """
    logger.info("üéØ Requ√™te re√ßue sur /api/confidence-analysis - transfert vers vosk-stt + mistral")
    
    if 'audio' not in request.files:
        return jsonify({"error": "No audio file provided"}), 400

    audio_file = request.files['audio']
    session_id = request.form.get('session_id', f"session_{int(time.time())}")
    scenario = request.form.get('scenario', 'confidence_boost')
    
    try:
        # √âTAPE 1: Transcription avec Vosk
        async with httpx.AsyncClient() as client:
            files = {'audio': (audio_file.filename, audio_file.read(), audio_file.mimetype)}
            data = {
                'session_id': session_id,
                'scenario': scenario,
                'language': 'fr'
            }
            
            logger.info(f"üîµ Envoi vers Vosk STT: {session_id}")
            vosk_response = await client.post(
                "http://vosk-stt:8002/analyze",
                files=files,
                data=data,
                timeout=30
            )
            vosk_response.raise_for_status()
            vosk_result = vosk_response.json()
            
            transcription = vosk_result.get("transcription", "")
            logger.info(f"‚úÖ Transcription Vosk: {transcription[:100]}...")
            
            if not transcription.strip():
                return jsonify({
                    "error": "Aucune transcription d√©tect√©e",
                    "transcription": "",
                    "ai_response": "Je n'ai pas pu comprendre votre audio. Pouvez-vous r√©p√©ter ?",
                    "confidence_score": 0.0
                }), 200
        
        # √âTAPE 2: G√©n√©ration r√©ponse IA avec Mistral
        async with httpx.AsyncClient() as client:
            mistral_payload = {
                "model": "mistral-nemo-instruct-2407",
                "messages": [
                    {
                        "role": "system",
                        "content": f"""Tu es Marie, coach en confiance vocale pour l'exercice '{scenario}'.
                        Analyse cette transcription et donne un feedback constructif et encourageant en fran√ßais.
                        Sois bienveillante, pr√©cise et motivante. Limite ta r√©ponse √† 2-3 phrases."""
                    },
                    {
                        "role": "user",
                        "content": f"Voici ma r√©ponse √† analyser: '{transcription}'"
                    }
                ],
                "temperature": 0.7,
                "max_tokens": 200
            }
            
            logger.info(f"üîµ Envoi vers Mistral: {session_id}")
            mistral_response = await client.post(
                "http://mistral-conversation:8001/v1/chat/completions",
                json=mistral_payload,
                timeout=30
            )
            mistral_response.raise_for_status()
            mistral_result = mistral_response.json()
            
            ai_response = mistral_result["choices"][0]["message"]["content"]
            logger.info(f"‚úÖ R√©ponse Mistral: {ai_response[:100]}...")
        
        # √âTAPE 3: Calcul score de confiance basique
        confidence_score = min(0.9, len(transcription.split()) / 10.0)
        
        # √âTAPE 4: R√©ponse format√©e pour Flutter
        result = {
            "transcription": transcription,
            "ai_response": ai_response,
            "confidence_score": confidence_score,
            "session_id": session_id,
            "scenario": scenario,
            "metrics": {
                "clarity": vosk_result.get("scores", {}).get("clarity", confidence_score),
                "fluency": vosk_result.get("scores", {}).get("fluency", confidence_score),
                "confidence": confidence_score,
                "pace": vosk_result.get("scores", {}).get("pace", 0.7)
            },
            "timestamp": time.time()
        }
        
        logger.info(f"‚úÖ Analyse compl√®te termin√©e pour {session_id}")
        return jsonify(result), 200

    except httpx.RequestError as e:
        logger.error(f"‚ùå Erreur r√©seau: {e}")
        return jsonify({
            "error": f"Erreur de communication: {str(e)}",
            "transcription": "",
            "ai_response": "D√©sol√©, je rencontre un probl√®me technique. R√©essayez dans quelques instants.",
            "confidence_score": 0.0
        }), 500
    except Exception as e:
        logger.error(f"‚ùå Erreur inattendue: {e}")
        return jsonify({
            "error": f"Erreur interne: {str(e)}",
            "transcription": "",
            "ai_response": "Une erreur inattendue s'est produite. Veuillez r√©essayer.",
            "confidence_score": 0.0
        }), 500

@app.route('/api/sessions/active', methods=['GET'])
def get_active_sessions():
    """
    DIAGNOSTIC: Endpoint pour consulter les sessions actives
    """
    try:
        with session_lock:
            # Nettoyer les sessions expir√©es
            current_time = time.time()
            expired_keys = []
            for key, session in active_sessions.items():
                session_age = current_time - session.get('created_timestamp', 0)
                if session_age > 1800:  # 30 minutes
                    expired_keys.append(key)
            
            for key in expired_keys:
                logger.info(f"üóëÔ∏è Nettoyage session expir√©e: {active_sessions[key]['room_name']}")
                del active_sessions[key]
            
            sessions_info = {
                "active_sessions": dict(active_sessions),
                "total_active": len(active_sessions),
                "timestamp": datetime.utcnow().isoformat()
            }
        
        logger.info(f"üìä Sessions actives consult√©es: {len(active_sessions)} sessions")
        return jsonify(sessions_info), 200
        
    except Exception as e:
        logger.error(f"‚ùå DIAGNOSTIC: Erreur consultation sessions: {str(e)}")
        return jsonify({"error": f"Erreur consultation sessions: {str(e)}"}), 500

@app.route('/api/agents/status', methods=['GET'])
def get_agents_status():
    """
    DIAGNOSTIC: Endpoint pour consulter l'√©tat des agents
    """
    try:
        # Note: Service agent d√©sactiv√© pour approche REST + Vosk
        agents_info = {
            "active_agents_count": 0,
            "timestamp": datetime.utcnow().isoformat(),
            "service_status": "disabled_rest_mode"
        }
        
        logger.info("üîß Service agent d√©sactiv√© - Mode REST + Vosk")
        return jsonify(agents_info), 200
        
    except Exception as e:
        logger.error(f"‚ùå DIAGNOSTIC: Erreur consultation agents: {str(e)}")
        return jsonify({"error": f"Erreur consultation agents: {str(e)}"}), 500


# SYSTEME ADAPTATIF - Endpoints de monitoring
@app.route('/adaptive/status', methods=['GET'])
def get_adaptive_status():
    """Obtenir le statut du syst√®me adaptatif"""
    try:
        # V√©rifier si le syst√®me adaptatif est disponible
        try:
            from services.streaming_integration import StreamingIntegration
            available = True
        except ImportError:
            available = False
        
        if hasattr(app, 'adaptive_streamer') and app.adaptive_streamer:
            metrics = app.adaptive_streamer.get_performance_report()
            return jsonify({
                'status': 'active',
                'available': True,
                'efficiency': metrics.get('global_efficiency_percent', 0),
                'profile': metrics.get('current_profile', 'unknown'),
                'sessions': metrics.get('sessions_count', 0),
                'improvement': metrics.get('improvement_factor', 0)
            })
        else:
            return jsonify({
                'status': 'available_not_active' if available else 'not_available',
                'available': available,
                'message': 'Systeme adaptatif disponible mais pas encore utilise' if available else 'Fichiers adaptatifs manquants'
            })
    except Exception as e:
        return jsonify({
            'status': 'error',
            'available': False,
            'error': str(e)
        })

@app.route('/adaptive/test', methods=['POST'])
def test_adaptive_system():
    """Tester le syst√®me adaptatif"""
    try:
        from services.streaming_integration import StreamingIntegration
        from unittest.mock import Mock
        
        # Mock room pour test
        mock_room = Mock()
        mock_room.local_participant = Mock()
        
        # Test d'int√©gration
        integration = StreamingIntegration(mock_room, use_adaptive=True)
        
        return jsonify({
            'status': 'success',
            'message': 'Systeme adaptatif fonctionnel',
            'mode': integration.get_current_mode()
        })
    except Exception as e:
        return jsonify({
            'status': 'error',
            'error': str(e)
        })

@app.route('/api/story/generate-elements', methods=['POST'])
def generate_story_elements():
    """
    G√©n√®re des √©l√©ments narratifs personnalis√©s via Mistral AI
    """
    logger.info("üéØ Requ√™te g√©n√©ration √©l√©ments narratifs re√ßue")
    
    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "Donn√©es JSON requises"}), 400
            
        # Extraction des param√®tres
        genre = data.get('genre')  # Ex: 'fantasy', 'adventure', etc.
        difficulty = data.get('difficulty', 'medium')  # 'easy', 'medium', 'hard', 'expert'
        keywords = data.get('keywords', [])  # Liste de mots-cl√©s optionnels
        user_id = data.get('user_id', 'anonymous')
        
        logger.info(f"üîß Param√®tres: genre={genre}, difficult√©={difficulty}, mots-cl√©s={keywords}")
        
        # Construction du prompt structur√© pour Mistral
        prompt = _build_story_elements_prompt(genre, difficulty, keywords)
        
        # Appel au service Mistral (version synchrone)
        with httpx.Client() as client:
            mistral_payload = {
                "model": "mistral-nemo-instruct-2407",
                "messages": [
                    {
                        "role": "system",
                        "content": "Tu es un cr√©ateur d'histoires expert. R√©ponds UNIQUEMENT avec du JSON valide."
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                "temperature": 0.8,  # Plus cr√©atif pour la g√©n√©ration
                "max_tokens": 1200
            }
            
            logger.info("üîµ Envoi vers Mistral pour g√©n√©ration √©l√©ments")
            mistral_response = client.post(
                "http://localhost:8001/v1/chat/completions",
                json=mistral_payload,
                timeout=30
            )
            mistral_response.raise_for_status()
            mistral_result = mistral_response.json()
            
            # Extraction du contenu g√©n√©r√©
            generated_content = mistral_result["choices"][0]["message"]["content"]
            logger.info(f"‚úÖ Contenu g√©n√©r√© par Mistral: {generated_content[:200]}...")
            
            # Tentative de parsing JSON avec nettoyage
            try:
                # Nettoyer le contenu : supprimer les pr√©fixes markdown et espaces
                clean_content = generated_content.strip()
                if clean_content.startswith('```json'):
                    clean_content = clean_content[7:]  # Supprimer ```json
                if clean_content.endswith('```'):
                    clean_content = clean_content[:-3]  # Supprimer ```
                clean_content = clean_content.strip()
                
                parsed_elements = json.loads(clean_content)
                elements = parsed_elements.get('elements', [])
                story_seed = parsed_elements.get('story_seed', '')
                
                # Validation des √©l√©ments g√©n√©r√©s
                if len(elements) >= 3:
                    logger.info(f"‚úÖ {len(elements)} √©l√©ments g√©n√©r√©s avec succ√®s")
                    return jsonify({
                        "success": True,
                        "elements": elements,
                        "story_seed": story_seed,
                        "generation_params": {
                            "genre": genre,
                            "difficulty": difficulty,
                            "keywords": keywords
                        },
                        "timestamp": time.time()
                    }), 200
                else:
                    logger.warning(f"‚ö†Ô∏è Nombre d'√©l√©ments insuffisant: {len(elements)}")
                    return _generate_fallback_elements(genre, difficulty, keywords)
                    
            except json.JSONDecodeError as e:
                logger.error(f"‚ùå Erreur parsing JSON Mistral: {e}")
                return _generate_fallback_elements(genre, difficulty, keywords)
        
    except httpx.RequestError as e:
        logger.error(f"‚ùå Erreur r√©seau Mistral: {e}")
        return _generate_fallback_elements(genre, difficulty, keywords)
    except Exception as e:
        logger.error(f"‚ùå Erreur inattendue g√©n√©ration √©l√©ments: {e}")
        return _generate_fallback_elements(genre, difficulty, keywords)

def _build_story_elements_prompt(genre, difficulty, keywords):
    """Construit le prompt pour la g√©n√©ration d'√©l√©ments narratifs"""
    
    # Simplification pour √©viter les erreurs Unicode
    genre_simple = genre if genre else "general"
    keywords_text = f" incluant les mots: {', '.join(keywords)}" if keywords else ""
    
    return f"""Create exactly 3 story elements in French for a {genre_simple} story.

REQUIREMENTS:
- Genre: {genre_simple}
- Difficulty: {difficulty}
- Keywords to include: {keywords}{keywords_text}

RESPONSE FORMAT (JSON ONLY, NO EXTRA TEXT):
{{
  "elements": [
    {{
      "type": "character",
      "name": "Character Name",
      "emoji": "üßô‚Äç‚ôÇÔ∏è",
      "description": "Simple description without accents",
      "keywords": ["word1", "word2"],
      "difficulty": "{difficulty}"
    }},
    {{
      "type": "location",
      "name": "Location Name",
      "emoji": "üè∞",
      "description": "Simple description without accents",
      "keywords": ["word1", "word2"],
      "difficulty": "{difficulty}"
    }},
    {{
      "type": "magic_object",
      "name": "Object Name",
      "emoji": "üîÆ",
      "description": "Simple description without accents",
      "keywords": ["word1", "word2"],
      "difficulty": "{difficulty}"
    }}
  ],
  "story_seed": "Simple connection phrase without accents"
}}

Generate NOW (JSON only):"""

def _generate_fallback_elements(genre, difficulty, keywords):
    """G√©n√®re des √©l√©ments de fallback en cas d'erreur Mistral"""
    logger.info("üîß G√©n√©ration √©l√©ments de fallback")
    
    # Assurer une difficult√© valide pour les fallbacks
    fallback_difficulty = difficulty if difficulty in ['easy', 'medium', 'hard', 'expert'] else 'medium'
    
    fallback_elements = [
        {
            "type": "character",
            "name": "H√©ros Myst√©rieux",
            "emoji": "ü¶∏‚Äç‚ôÇÔ∏è",
            "description": "Un personnage aux capacit√©s extraordinaires qui cache un secret profond",
            "keywords": ["myst√®re", "h√©ros", "secret"],
            "difficulty": fallback_difficulty
        },
        {
            "type": "location",
            "name": "For√™t Enchant√©e",
            "emoji": "üå≤",
            "description": "Une for√™t magique o√π les arbres murmurent des secrets anciens",
            "keywords": ["for√™t", "magie", "ancien"],
            "difficulty": fallback_difficulty
        },
        {
            "type": "magic_object",
            "name": "Cristal de Lumi√®re",
            "emoji": "üíé",
            "description": "Un cristal scintillant qui r√©v√®le la v√©rit√© cach√©e dans l'obscurit√©",
            "keywords": ["cristal", "lumi√®re", "v√©rit√©"],
            "difficulty": fallback_difficulty
        }
    ]
    
    return jsonify({
        "success": True,
        "elements": fallback_elements,
        "story_seed": "Un h√©ros myst√©rieux d√©couvre un cristal magique dans une for√™t enchant√©e qui va r√©v√©ler des secrets ancestraux.",
        "generation_params": {
            "genre": genre,
            "difficulty": difficulty,
            "keywords": keywords
        },
        "fallback": True,
        "timestamp": time.time()
    }), 200

@app.route('/api/story/analyze-narrative', methods=['POST'])
def analyze_complete_narrative():
    """
    Analyse compl√®te d'une histoire avec Vosk STT + Mistral AI
    """
    logger.info("üéØ Requ√™te analyse narrative compl√®te re√ßue")
    
    # V√©rifier si c'est un upload audio ou des donn√©es JSON
    if 'audio' in request.files:
        # Mode audio : Vosk STT + Mistral AI
        return _analyze_narrative_from_audio()
    else:
        # Mode texte : Mistral AI direct
        return _analyze_narrative_from_text()

def _analyze_narrative_from_audio():
    """Analyse narrative √† partir d'un fichier audio (Vosk + Mistral)"""
    try:
        audio_file = request.files['audio']
        session_id = request.form.get('session_id', f"story_analysis_{int(time.time())}")
        story_title = request.form.get('story_title', 'Histoire racont√©e')
        story_elements = request.form.get('story_elements', '[]')
        genre = request.form.get('genre')
        
        # Parser les √©l√©ments d'histoire
        try:
            elements_list = json.loads(story_elements)
        except:
            elements_list = []
        
        logger.info(f"üîß Analyse audio pour: {story_title}")
        
        # √âTAPE 1: Transcription avec Vosk (version synchrone)
        with httpx.Client() as client:
            files = {'audio': (audio_file.filename, audio_file.read(), audio_file.mimetype)}
            data = {
                'session_id': session_id,
                'scenario': 'story_analysis',
                'language': 'fr'
            }
            
            logger.info(f"üîµ Envoi vers Vosk STT: {session_id}")
            vosk_response = client.post(
                "http://vosk-stt:8002/analyze",
                files=files,
                data=data,
                timeout=30
            )
            vosk_response.raise_for_status()
            vosk_result = vosk_response.json()
            
            transcription = vosk_result.get("transcription", "")
            logger.info(f"‚úÖ Transcription Vosk: {transcription[:100]}...")
            
            if not transcription.strip():
                return jsonify({
                    "error": "Aucune transcription d√©tect√©e",
                    "transcription": "",
                    "analysis": _generate_fallback_narrative_analysis(story_title, elements_list, genre)[0].get_json()["analysis"],
                    "fallback": True
                }), 200
        
        # √âTAPE 2: Analyse narrative avec Mistral
        return _analyze_transcribed_narrative(transcription, story_title, elements_list, genre, session_id)
        
    except Exception as e:
        logger.error(f"‚ùå Erreur analyse narrative audio: {e}")
        return jsonify({
            "error": f"Erreur analyse audio: {str(e)}",
            "transcription": "",
            "analysis": _generate_fallback_narrative_analysis("Histoire", [], None)[0].get_json()["analysis"],
            "fallback": True
        }), 500

def _analyze_narrative_from_text():
    """Analyse narrative √† partir de texte (Mistral AI direct)"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "Donn√©es JSON requises"}), 400
            
        # Extraction des param√®tres
        story_title = data.get('story_title', 'Histoire sans titre')
        full_narrative = data.get('full_narrative', '')
        story_elements = data.get('story_elements', [])
        genre = data.get('genre')
        session_id = data.get('session_id', f"story_text_{int(time.time())}")
        
        logger.info(f"üîß Analyse texte pour: {story_title}")
        
        if not full_narrative.strip():
            return jsonify({"error": "R√©cit narratif requis"}), 400
        
        return _analyze_transcribed_narrative(full_narrative, story_title, story_elements, genre, session_id)
        
    except Exception as e:
        logger.error(f"‚ùå Erreur analyse narrative texte: {e}")
        return jsonify({
            "error": f"Erreur analyse texte: {str(e)}",
            "analysis": _generate_fallback_narrative_analysis("Histoire", [], None)[0].get_json()["analysis"],
            "fallback": True
        }), 500

def _analyze_transcribed_narrative(narrative_text, story_title, story_elements, genre, session_id):
    """Analyse du texte narratif avec Mistral AI"""
    try:
        # Construction du prompt d'analyse structur√©
        prompt = _build_narrative_analysis_prompt(
            story_title, narrative_text, story_elements, genre
        )
        
        # Appel au service Mistral
        with httpx.Client() as client:
            mistral_payload = {
                "model": "mistral-nemo-instruct-2407",
                "messages": [
                    {
                        "role": "system",
                        "content": "Tu es un expert en analyse narrative. R√©ponds UNIQUEMENT avec du JSON valide."
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                "temperature": 0.6,  # Moins cr√©atif, plus analytique
                "max_tokens": 1000
            }
            
            logger.info("üîµ Envoi vers Mistral pour analyse narrative")
            mistral_response = client.post(
                "http://localhost:8001/v1/chat/completions",
                json=mistral_payload,
                timeout=30
            )
            mistral_response.raise_for_status()
            mistral_result = mistral_response.json()
            
            # Extraction du contenu g√©n√©r√©
            generated_content = mistral_result["choices"][0]["message"]["content"]
            logger.info(f"‚úÖ Analyse g√©n√©r√©e par Mistral: {generated_content[:200]}...")
            
            # Tentative de parsing JSON avec nettoyage
            try:
                # Nettoyer le contenu : supprimer les pr√©fixes markdown et espaces
                clean_content = generated_content.strip()
                if clean_content.startswith('```json'):
                    clean_content = clean_content[7:]
                if clean_content.endswith('```'):
                    clean_content = clean_content[:-3]
                clean_content = clean_content.strip()
                
                analysis_result = json.loads(clean_content)
                
                logger.info("‚úÖ Analyse narrative g√©n√©r√©e avec succ√®s")
                return jsonify({
                    "success": True,
                    "transcription": narrative_text,
                    "analysis": analysis_result,
                    "session_id": session_id,
                    "analysis_params": {
                        "story_title": story_title,
                        "narrative_length": len(narrative_text),
                        "elements_count": len(story_elements),
                        "genre": genre
                    },
                    "timestamp": time.time()
                }), 200
                    
            except json.JSONDecodeError as e:
                logger.error(f"‚ùå Erreur parsing JSON analyse narrative: {e}")
                fallback_response = _generate_fallback_narrative_analysis(story_title, story_elements, genre)[0].get_json()
                fallback_response["transcription"] = narrative_text
                fallback_response["session_id"] = session_id
                return jsonify(fallback_response), 200
        
    except httpx.RequestError as e:
        logger.error(f"‚ùå Erreur r√©seau Mistral: {e}")
        fallback_response = _generate_fallback_narrative_analysis(story_title, story_elements, genre)[0].get_json()
        fallback_response["transcription"] = narrative_text
        fallback_response["session_id"] = session_id
        return jsonify(fallback_response), 200
    except Exception as e:
        logger.error(f"‚ùå Erreur inattendue analyse narrative: {e}")
        fallback_response = _generate_fallback_narrative_analysis(story_title, story_elements, genre)[0].get_json()
        fallback_response["transcription"] = narrative_text
        fallback_response["session_id"] = session_id
        return jsonify(fallback_response), 200

def _build_narrative_analysis_prompt(title, narrative, elements, genre):
    """Construit le prompt pour l'analyse narrative"""
    
    elements_text = ", ".join([elem.get('name', elem) if isinstance(elem, dict) else str(elem) for elem in elements])
    genre_text = genre if genre else "libre"
    
    return f"""Analyze this complete story narrative in French:

STORY DETAILS:
- Title: {title}
- Genre: {genre_text}
- Required elements: {elements_text}
- Full narrative: "{narrative}"

ANALYSIS REQUIRED:
Evaluate the story on these criteria:
1. Creative use of required elements
2. Plot coherence and structure
3. Narrative fluency and pacing
4. Originality and creativity
5. Genre consistency (if applicable)

RESPONSE FORMAT (JSON ONLY):
{{
  "overall_score": 0.85,
  "element_usage_score": 0.9,
  "plot_coherence_score": 0.8,
  "fluidity_score": 0.85,
  "creativity_score": 0.9,
  "genre_consistency_score": 0.8,
  "strengths": ["Strong creative element use", "Good pacing", "Engaging plot"],
  "improvements": ["Develop character depth", "Strengthen conclusion"],
  "highlight_moments": ["Creative element integration", "Plot twist moment"],
  "narrative_feedback": "Well-structured story with excellent use of required elements and good narrative flow."
}}

Analyze NOW (JSON only):"""

def _generate_fallback_narrative_analysis(title, elements, genre):
    """G√©n√®re une analyse de fallback en cas d'erreur Mistral"""
    logger.info("üîß G√©n√©ration analyse narrative de fallback")
    
    fallback_analysis = {
        "overall_score": 0.75,
        "element_usage_score": 0.8,
        "plot_coherence_score": 0.7,
        "fluidity_score": 0.75,
        "creativity_score": 0.8,
        "genre_consistency_score": 0.75,
        "strengths": ["Utilisation cr√©ative des √©l√©ments", "Histoire coh√©rente", "Bonne fluidit√© narrative"],
        "improvements": ["D√©velopper davantage les personnages", "Renforcer les transitions"],
        "highlight_moments": ["Int√©gration cr√©ative des √©l√©ments impos√©s", "Moment de tension r√©ussi"],
        "narrative_feedback": "Histoire bien construite avec une utilisation coh√©rente des √©l√©ments impos√©s. Continue √† d√©velopper ton style narratif !"
    }
    
    return jsonify({
        "success": True,
        "analysis": fallback_analysis,
        "analysis_params": {
            "story_title": title,
            "elements_count": len(elements),
            "genre": genre
        },
        "fallback": True,
        "timestamp": time.time()
    }), 200

@app.route('/dashboard')
def serve_dashboard():
    """Servir le dashboard adaptatif via le serveur Flask"""
    try:
        import os
        dashboard_path = os.path.join(os.path.dirname(__file__), 'dashboard_adaptive.html')
        return send_file(dashboard_path)
    except Exception as e:
        return jsonify({
            'error': 'Dashboard non trouv√©',
            'details': str(e)
        }), 404

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8000, debug=True)
