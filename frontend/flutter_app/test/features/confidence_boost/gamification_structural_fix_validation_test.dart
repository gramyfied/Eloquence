import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:eloquence_2_0/features/confidence_boost/presentation/providers/confidence_boost_provider.dart';
import 'package:eloquence_2_0/features/confidence_boost/domain/entities/gamification_models.dart' as gamification;
import 'package:eloquence_2_0/features/confidence_boost/domain/entities/confidence_models.dart' as confidence_models;
import 'package:eloquence_2_0/features/confidence_boost/domain/entities/confidence_scenario.dart' as confidence_scenarios;
import 'package:eloquence_2_0/features/confidence_boost/data/services/confidence_analysis_backend_service.dart';
import 'package:eloquence_2_0/features/confidence_boost/data/services/prosody_analysis_interface.dart';
import 'package:eloquence_2_0/features/confidence_boost/data/repositories/gamification_repository.dart';
import 'package:eloquence_2_0/features/confidence_boost/data/services/xp_calculator_service.dart';
import 'package:eloquence_2_0/features/confidence_boost/data/services/badge_service.dart';
import 'package:eloquence_2_0/features/confidence_boost/data/services/streak_service.dart';
import 'package:eloquence_2_0/features/confidence_boost/data/services/gamification_service.dart';
import 'package:eloquence_2_0/features/confidence_boost/data/datasources/confidence_remote_datasource.dart';
import '../../fakes/fake_clean_livekit_service.dart';
import '../../fakes/fake_api_service.dart';

// Mock classes simples pour les tests
class MockConfidenceRemoteDataSource implements ConfidenceRemoteDataSource {
  @override
  Future<List<confidence_scenarios.ConfidenceScenario>> getScenarios() async {
    debugPrint('üîß MockConfidenceRemoteDataSource.getScenarios() appel√©');
    return [
      const confidence_scenarios.ConfidenceScenario(
        id: 'test-scenario',
        title: 'Test Scenario',
        description: 'Scenario de test',
        prompt: 'Test prompt',
        type: confidence_models.ConfidenceScenarioType.presentation,
        durationSeconds: 60,
        tips: ['Test tip'],
        keywords: ['test', 'scenario'],
        difficulty: 'intermediate',
        icon: 'üéØ',
      ),
    ];
  }

  @override
  Future<confidence_models.ConfidenceAnalysis> analyzeAudio({
    required String audioFilePath,
    required confidence_scenarios.ConfidenceScenario scenario,
  }) async {
    debugPrint('üîß MockConfidenceRemoteDataSource.analyzeAudio() appel√©');
    return confidence_models.ConfidenceAnalysis(
      overallScore: 0.85,
      confidenceScore: 0.85,
      fluencyScore: 0.82,
      clarityScore: 0.88,
      energyScore: 0.80,
      wordCount: 120,
      speakingRate: 150.0,
      keywordsUsed: ['test'],
      transcription: 'Mock transcription',
      feedback: 'Mock feedback',
      strengths: ['Mock strength'],
      improvements: ['Mock improvement'],
    );
  }
}

class MockConfidenceAnalysisBackendService extends ConfidenceAnalysisBackendService {
  @override
  Future<bool> isServiceAvailable() async => false;
}

class MockProsodyAnalysisInterface extends FallbackProsodyAnalysis {}

class MockGamificationRepository extends HiveGamificationRepository {
  @override
  Future<void> initialize() async {}
}

class MockXPCalculatorService extends XPCalculatorService {}

class MockBadgeService extends BadgeService {
  MockBadgeService() : super(MockGamificationRepository());
}

class MockStreakService extends StreakService {
  MockStreakService() : super(MockGamificationRepository());
}

class MockGamificationService extends GamificationService {
  MockGamificationService() : super(
    MockGamificationRepository(),
    MockBadgeService(),
    MockXPCalculatorService(),
    MockStreakService()
  );
}

void main() {
  group('Validation de la Correction Structurelle - M√©thodes de D√©monstration Gamification', () {
    late ProviderContainer container;

    setUp(() async {
      // Initialiser SharedPreferences pour les tests
      SharedPreferences.setMockInitialValues({});
      final prefs = await SharedPreferences.getInstance();
      
      // Cr√©er le container avec tous les providers mock√©s
      container = ProviderContainer(
        overrides: [
          // Override SharedPreferences provider
          sharedPreferencesProvider.overrideWithValue(prefs),
          
          // Override ApiService provider avec fake
          apiServiceProvider.overrideWithValue(FakeApiService()),
          
          // Override LiveKit service avec fake
          livekitServiceProvider.overrideWithValue(FakeCleanLiveKitService()),
          
          // Override Mistral API service avec fake
// import 'package:eloquence_2_0/features/confidence_boost/presentation/providers/mistral_api_service_provider.dart';
          // TODO: Ajouter l'override du provider correctement ici si n√©cessaire
          
          // Override autres services avec mocks simples
          confidenceAnalysisBackendServiceProvider.overrideWithValue(MockConfidenceAnalysisBackendService()),
          prosodyAnalysisInterfaceProvider.overrideWithValue(MockProsodyAnalysisInterface()),
          
          // üîß CORRECTION CRITIQUE: Override confidenceRemoteDataSourceProvider pour √©viter l'appel √† Supabase
          confidenceRemoteDataSourceProvider.overrideWithValue(MockConfidenceRemoteDataSource()),
          
          // Correction pour FutureProvider: utiliser overrideWith pour retourner une Future
          gamificationRepositoryProvider.overrideWith((ref) async => MockGamificationRepository()),
          xpCalculatorServiceProvider.overrideWithValue(MockXPCalculatorService()),
          badgeServiceProvider.overrideWithValue(MockBadgeService()),
          streakServiceProvider.overrideWithValue(MockStreakService()),
          gamificationServiceProvider.overrideWithValue(MockGamificationService()),
        ],
      );
    });

    tearDown(() {
      container.dispose();
    });

    testWidgets('VALIDATION DIRECTE: M√©thodes de d√©monstration sont accessibles et fonctionnelles', (WidgetTester tester) async {
      debugPrint('\nüîß === TEST DIRECT DES M√âTHODES D√âPLAC√âES ===');
      
      final notifier = container.read(confidenceBoostProvider.notifier);
      
      // Test 1: createDemoGamificationData
      debugPrint('üìù Test de createDemoGamificationData()...');
      await notifier.createDemoGamificationData();
      
      // V√©rifier l'√©tat apr√®s l'appel
      container.read(confidenceBoostProvider);
      final demoResult = notifier.lastGamificationResult;
      
      expect(demoResult, isNotNull, reason: 'createDemoGamificationData doit g√©n√©rer un r√©sultat');
      expect(demoResult!.earnedXP, greaterThan(0), reason: 'XP doit √™tre positif');
      expect(demoResult.newBadges, isNotEmpty, reason: 'Des badges doivent √™tre pr√©sents');
      expect(demoResult.streakInfo, isNotNull, reason: 'StreakInfo doit √™tre pr√©sent');
      expect(demoResult.bonusMultiplier, isNotNull, reason: 'BonusMultiplier doit √™tre pr√©sent');
      debugPrint('‚úÖ createDemoGamificationData fonctionne: XP=${demoResult.earnedXP}, Badges=${demoResult.newBadges.length}');
      
      // Test 2: createDemoGamificationDataWithLevelUp
      debugPrint('üìù Test de createDemoGamificationDataWithLevelUp()...');
      await notifier.createDemoGamificationDataWithLevelUp();
      
      final levelUpResult = notifier.lastGamificationResult;
      expect(levelUpResult, isNotNull, reason: 'createDemoGamificationDataWithLevelUp doit g√©n√©rer un r√©sultat');
      expect(levelUpResult!.earnedXP, greaterThan(demoResult.earnedXP), reason: 'Level up doit donner plus d\'XP');
      expect(levelUpResult.newBadges.any((b) => b.rarity == gamification.BadgeRarity.epic), isTrue,
        reason: 'Level up doit inclure des badges √©piques');
      expect(levelUpResult.levelUp, isTrue, reason: 'Level up doit √™tre activ√©');
      debugPrint('‚úÖ createDemoGamificationDataWithLevelUp fonctionne: XP=${levelUpResult.earnedXP}, Level=${levelUpResult.newLevel}, Badges √©piques=${levelUpResult.newBadges.where((b) => b.rarity == gamification.BadgeRarity.epic).length}');
      
      // Test 3: clearDemoGamificationData
      debugPrint('üìù Test de clearDemoGamificationData()...');
      notifier.clearDemoGamificationData();
      
      final clearedResult = notifier.lastGamificationResult;
      expect(clearedResult, isNull, reason: 'clearDemoGamificationData doit effacer les donn√©es');
      debugPrint('‚úÖ clearDemoGamificationData fonctionne: √âtat effac√© correctement');
      
      debugPrint('üéâ TOUTES LES M√âTHODES D√âPLAC√âES FONCTIONNENT CORRECTEMENT!');
    });

    testWidgets('VALIDATION STRUCTURELLE: V√©rification que les m√©thodes ne sont plus dans le scope invalide', (WidgetTester tester) async {
      debugPrint('\nüîç === VALIDATION DE LA CORRECTION STRUCTURELLE ===');
      
      final notifier = container.read(confidenceBoostProvider.notifier);
      
      // Tester que les m√©thodes sont maintenant accessibles comme m√©thodes de classe
      debugPrint('üìù V√©rification de l\'accessibilit√© des m√©thodes comme membres de ConfidenceBoostProvider...');
      
      // Test que la m√©thode createDemoGamificationData est accessible
      final hasCreateDemo = notifier.createDemoGamificationData;
      expect(hasCreateDemo, isNotNull, reason: 'createDemoGamificationData doit √™tre accessible');
      
      // Test que la m√©thode createDemoGamificationDataWithLevelUp est accessible
      final hasCreateDemoLevelUp = notifier.createDemoGamificationDataWithLevelUp;
      expect(hasCreateDemoLevelUp, isNotNull, reason: 'createDemoGamificationDataWithLevelUp doit √™tre accessible');
      
      // Test que la m√©thode clearDemoGamificationData est accessible
      final hasClearDemo = notifier.clearDemoGamificationData;
      expect(hasClearDemo, isNotNull, reason: 'clearDemoGamificationData doit √™tre accessible');
      
      debugPrint('‚úÖ SUCC√àS: Toutes les m√©thodes de d√©monstration sont maintenant accessibles comme m√©thodes de classe');
      debugPrint('üéØ CORRECTION STRUCTURELLE VALID√âE: Les m√©thodes ne sont plus pi√©g√©es dans le scope du try-catch');
    });

    testWidgets('VALIDATION INT√âGRATION: Test du fallback d\'urgence avec d√©monstration', (WidgetTester tester) async {
      debugPrint('\nüö® === TEST DU FALLBACK D\'URGENCE AVEC D√âMONSTRATION ===');
      
      final notifier = container.read(confidenceBoostProvider.notifier);
      
      // Simuler un appel direct au fallback (comme dans analyzePerformance)
      debugPrint('üìù Test direct de la g√©n√©ration de donn√©es de d√©monstration...');
      await notifier.createDemoGamificationData();
      
      // R√©cup√©rer les donn√©es g√©n√©r√©es depuis l'√©tat du provider
      final demoData = notifier.lastGamificationResult;
      expect(demoData, isNotNull, reason: 'Les donn√©es de d√©monstration doivent √™tre g√©n√©r√©es');
      
      // V√©rifications compl√®tes des donn√©es g√©n√©r√©es
      expect(demoData!.earnedXP, inInclusiveRange(30, 300), reason: 'XP doit √™tre dans la plage r√©aliste');
      expect(demoData.newBadges.length, inInclusiveRange(1, 3), reason: 'Nombre de badges r√©aliste');
      expect(demoData.streakInfo.currentStreak, greaterThan(0), reason: 'Streak doit √™tre positif');
      expect(demoData.bonusMultiplier, isNotNull, reason: 'BonusMultiplier doit √™tre pr√©sent');
      
      // Test des types de badges g√©n√©r√©s
      final badgeCategories = demoData.newBadges.map((b) => b.category.name).toSet();
      debugPrint('üèÜ Cat√©gories de badges g√©n√©r√©es: ${badgeCategories.join(', ')}');
      
      // Test des raret√©s de badges
      final badgeRarities = demoData.newBadges.map((b) => b.rarity.name).toSet();
      debugPrint('üíé Raret√©s de badges: ${badgeRarities.join(', ')}');
      
      // Validation des multiplicateurs
      final multiplier = demoData.bonusMultiplier;
      expect(multiplier.performanceMultiplier, greaterThanOrEqualTo(1.0), reason: 'Performance multiplier doit √™tre >= 1.0');
      expect(multiplier.streakMultiplier, greaterThanOrEqualTo(1.0), reason: 'Streak multiplier doit √™tre >= 1.0');
      expect(multiplier.difficultyMultiplier, greaterThanOrEqualTo(1.0), reason: 'Difficulty multiplier doit √™tre >= 1.0');
      
      debugPrint('‚úÖ SUCC√àS: Le fallback d\'urgence g√©n√®re des donn√©es de gamification compl√®tes et r√©alistes');
      debugPrint('üéâ CORRECTION STRUCTURELLE COMPL√àTEMENT VALID√âE!');
    });
  });
}